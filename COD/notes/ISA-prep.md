RISC-V -> stands for Reduced Instruction Set Computer 5.
The # 5 represents the gen. of the arch. 

# Why RISC-V?
- Open src 
- Can be implemented for both application specific and general purpose 
- other options need to be licensed 

# RISC vs CISC
- Instruction Set Complexity
- Load & Store Arch vs Direct Memory Access 
- Addressing Modes
- Number of clock cycles to execute Instructions
- Instruction Format 
- Mode of Execution: Pipelining & Non
- Number of on-chip Registers
- Complexity of Decoders, Control & Sequence Generator

# 5 Great Ideas
## Make the common case *Fast*
^7c7084
^79f7c8
The Load & Store comp. arch. separates instructions into:
- Mem. access operations (Load & Store) &
- Into operations that operate on the data in the register file -> Register to Register/ Register to Immediate.
By not combining mem. accesses with data manipulation operations, the processor's complexity is reduced which enable making the common case fast.
![[Pasted image 20240921182041.png]]

## Datapath
It is the collection of state elements, computation elements & interconnections, that together provide a path for the flow & transformation of data in the processor during execution.
Like above for eg.[[#^79f7c8]]


# Single Cycle RISC-v Processor(Non-Pipelined Arch.)
The Single Cycle contains 5 Stages which are namely:
![[Pasted image 20240921120626.png]]
- Instruction Fetch
	- Machine Code is Fetched from the mem. loca. pointed by PC.
	- PC[^new] = PC[^old] +4
	- ![[Pasted image 20240921115826.png]]
- Instruction Decode 
	- If it is R-type Instruction - Content of 2 src Registers is read(Reg1 & Reg2) & given to the Next stage & also enables destination Register (Ws).
	- If Load/ Store Instruction / I-Type Instruction - The Base Register content is read as Reg1 & the 12 bit Imm value as the offset.
	- ![[Pasted image 20240921115748.png]]
- Execution
	- If it is R-type Instruction - Arithmetic/Logical operation on the opr1 & opr2 is performed & result will be stored in ALUout register.
	- If Load/Store Instruction - the address of the data mem to be accessed is generated by adding the base register opr1 with 12 bit Imm value (offset) & stored in ALUout register.
	- ![[Pasted image 20240921120153.png]]
- Mem. Access
	- If Load - The ALUout is address of Data Mem. Loca. & the content is read & available at the output of MEM stage.
	- If Store - The ALUout is address of Data Mem. Loca. & content of src register is stored in Mem. Loca.
	- ![[Pasted image 20240921120418.png]]
- Write back
	- If it is R-type - Content of ALUout is stored into dest. register.
	- If Load Instruction - The Data read from the Mem. Loca. is stored into dest. register.
	- ![[Pasted image 20240921120600.png]]

# Introduction

>[!Note]
>RISC-v can't perform operations on more than 2 variables that is to say that we can only have the following semantics
>```asm
> instn dest, src, src
> or 
> instn(imm, reg) dest, src, imm
>```
>that is the only allowed format for all instructions 
>Therefore the natural number of operands for an operation like addition is 3.

## Why not more than 2 variables??
- Conforms to the philosophy of keeping the HW simple: hw for a variable number of operands is more complicated than hw for a fixed number.
- The situation illustrates the 1st of 3 underlying principles of hw designs:
## Design Principle 1: Simplicity favours Regularity.
Operations of the Computer
### HW
- Relationship of programs written in the higher lvl progamming langs to programs in this more primitive notation.
##### Does Compiler generate Single Assembly Instruction???
- The compiler must break this statement into several assembly instructions, since only one operation is performed per RISC-v instruction.
- The compiler creates a temporary variable, called t0,t1.. so on to store intermediate results.
### RISC-v Datapath
The Load-store comp. arch. [[#^7c7084]]
#### How Load-store arch. works?
Instruction(binary code) provides 2 info:
- Fields like opcode, func3 & func7 define the type & operation to be performed.
- Fields which can identify the dest. & src operands:
	- Dest. operand is:
		 1. Register
		 2. data mem. depending on type of instruction
	- Source operand is:
		1. Register
		2. Data mem. 
		3. Imm value/ constant
![[Pasted image 20240921182449.png]]

### Operands of the Computer HW
Operands Loca.: physical loca. in the computer.
- Register -> **Special Loca. built directly in Hw**
- Mem. Operands
- Constants( also called imm)

#### Registers as Operands
- Programming langs have simple variables that contain single/few data elements
- Operands in arithmetic instructions must be limited number of special loca. built directly in hw called registers.
- They are faster than mem.

##### In RISC-v
- The size of a register in the RISC-v arch. is 64 bits; known as double-word or 32 bit size known as word.
- Variables in programming lang can be of any number but registers in a hw are always limited.
- Eg. In RISC-v 64 bit processor - There are 32, 64 bit registers.
- Eg. In RISC-v 32 bit processor -  There are 32, 32 bit registers.

# Design Principle 2: "Smaller is faster"
## Why is there a limited number of registers?
- A very large number of registers may increase clock cycles time simply because it takes electronic signals longer time when they must travel farther.
- The number of bits it would take in the instruction format to address a register.
	- Eg. If number of register is 32, then the instruction format will have 5 bit field to address the registers, i.e., if there are 3 operands then the instruction format will have 3, 5 bit fields reserved.
	Increasing Number of registers means increase in bits required by these fields. This intern will increase size of instructions.
The RISC-v convention is x followed by number of the register except for a few register names that we will cover later
![[Pasted image 20240921190036.png]]

#### Risc-v Registers
![[Pasted image 20240921191820.png]]
- Registers can be used either name(i.e. ra, zero) or x0, x1, etc. Using name is preferred.
- Register used for specific purposes:
	- x0 Register: always holds the constant value 0.
	- Saved Register, s0-s11: used to hold variables
	- Temp. Register, t0-t6: used to hold intermediate values during a larger computation
	- Func. Args./return values
	- Pointers: stack, global, thread

### Data types
#### Double word 
it is 64 bits long or 8 bytes 
#### Word 
it is 32 bits long or 4 bytes
#### Half word
it is 16 bits long or 2 bytes
#### Byte
it is 8 bits wide or one byte
